What is trigger
===============
A trigger is a named PL/SQL block stored in the Oracle Database and executed automatically when a triggering event takes place. The event can be any of the following:

=>A data manipulation language  (DML) statement executed against a table e.g., INSERT, UPDATE, or DELETE. For example, if you define a trigger that fires before an INSERT statement on the emp table, the trigger will fire once before a new row is inserted into the emp table.

=>A data definition language (DDL) statement executes e.g., CREATE or ALTER statement. These triggers are often used for auditing purposes to record changes of the schema.
=>A system event such as startup or shutdown of the Oracle Database.
=>A user event such as login or logout.

Usage of Trigger
============
=>Enforcing complex business rules that cannot be established using integrity constraint such as UNIQUE, NOT NULL, and CHECK.
=>Preventing invalid transactions.

Syntax to create Trigger
=================
CREATE [OR REPLACE] TRIGGER trigger_name
{BEFORE | AFTER } triggering_event ON table_name
[FOR EACH ROW]
DECLARE
    declaration statements
BEGIN
    executable statements
EXCEPTION
    exception_handling statements
END;


CREATE TABLE audits (
      audit_id         NUMBER PRIMARY KEY,
      table_name       VARCHAR2(25),
      transaction_name VARCHAR2(10),
      by_user          VARCHAR2(30),
      transaction_date DATE
);
========================================
CREATE OR REPLACE TRIGGER dept_trigger
AFTER UPDATE OR DELETE OR INSERT ON Dept
FOR EACH ROW
DECLARE
	v_transaction VARCHAR(10);
BEGIN
	v_transaction := CASE
   		WHEN UPDATING THEN 'UPDATE'
   		WHEN DELETING THEN 'DELETE'
   		WHEN INSERTING THEN 'INSERT'
		END ;
INSERT INTO audits values(Audits_sequence.NEXTVAL,'Dept',v_transaction,USER,SYSDATE);
END;
==================================================

Statement-level triggers
=================
A statement-level trigger is fired whenever a trigger event occurs on a table regardless of how many rows are affected. In other words, a statement-level trigger executes once for each transaction.

By default, the statement CREATE TRIGGER creates a statement-level trigger when you omit the FOR EACH ROW clause.

CREATE [OR REPLACE] TRIGGER trigger_name
    {BEFORE | AFTER } triggering_event 
    ON table_name    
DECLARE
    declaration statements
BEGIN
    executable statements
EXCEPTION
    exception_handling statements
END;

CREATE TABLE customers
 (   customer_id NUMBER 
                GENERATED BY DEFAULT AS IDENTITY START WITH 100 
                PRIMARY KEY,
    name         VARCHAR2( 255 ) NOT NULL,
    address      VARCHAR2( 255 )         ,
    website      VARCHAR2( 255 )         ,
    credit_limit NUMBER( 8, 2 )
  );

Suppose, you want to restrict users to update credit of customers from 28th to 31st of every month so that you can close the financial month.

To enforce this rule, you can use this statement-level trigger:

CREATE OR REPLACE TRIGGER empsal_update
    BEFORE UPDATE OF sal
    ON emp
DECLARE
    v_day_of_month NUMBER;
BEGIN    
    v_day_of_month := EXTRACT(DAY FROM sysdate);
 
    IF v_day_of_month BETWEEN 1 AND 7 THEN
        raise_application_error(-20100,'Cannot update employees salary in 1st week of the month');
    END IF;
END;

Row-level triggers
=============
Row-level triggers fires once for each row affected by the triggering event such as INSERT, UPDATE, or DELETE.

Row-level triggers are useful for data-related activities such as data auditing and data validation.

To create a new row-level trigger, you use the CREATE TRIGGER statement with the FOR EACH ROW clause.

CREATE OR REPLACE TRIGGER trigger_name
    BEFORE | AFTER
    INSERT OR DELETE OR UPDATE OF column1, column2, …
    ON table_name
    FOR EACH ROW
    REFERENCING OLD AS old_name
    NEW AS new_name    
DECLARE
    …
BEGIN
    …
EXCEPTION
    …
END;

CREATE OR REPLACE TRIGGER empsalupdate_trg 
    BEFORE UPDATE OF sal
    ON emp
    FOR EACH ROW
BEGIN
    -- check the credit limit
    IF :NEW.Sal >= 2 * :OLD.sal THEN
        raise_application_error(-20101,'The new salary ' || :NEW.sal || 
            ' cannot increase to more than double, the current sal ' || :OLD.sal);
    END IF;
END;

What is an INSTEAD OF trigger
=============================
An INSTEAD OF trigger is a trigger that allows you to update data in tables via their view which cannot be modified directly through DML statements.

When you issue a DML statement such as INSERT, UPDATE, or DELETE to a non-updatable view, Oracle will issue an error.

If the view has an INSTEAD OF trigger, it will automatically skip the DML statement and execute other DML statements instead.

Note that an INSTEAD OF trigger is fired for each row of the view that gets modified.

In Oracle, you can create an INSTEAD OF trigger for a view only. You cannot create an INSTEAD OF trigger for a table.

CREATE [OR REPLACE] TRIGGER trigger_name
INSTEAD OF {INSERT | UPDATE | DELETE}
ON view_name
FOR EACH ROW
BEGIN
    EXCEPTION
    ...
END;



Trigger:
-----------
1) A Trigger is a stored procedure for particular table.
2) A Database Trigger is a stored procedure that is fired when an insert, update, delete, statement issued against a table.

Advantages:
-----------------
1) To generate data automatically
2) To enforce complex integrity constraints

Trigger Syntax:
---------------
create or replace trigger <trigger-name>
[before | after] [insert | update | delete] on <table-name> 
[for each row]
BEGIN
     [execution block]
EXCEPTION
     [exception block]
END;

Pl/ Sql Trigger to validate student table when user is trying to insert, delete or update records.
----------------------------------------------------------
create or replace Trigger transaction_check
before insert or update or delete on dept
begin
  Raise_Application_Error(-20000, 'Transaction Not Allowed on this Table');
end;
/

Pl / Sql Trigger to stop the Transactions on sundays.
-----------------------------------------------------------------------
create or replace Trigger transaction_sunday
before insert or delete or update on emp
begin
if to_char(sysdate, 'D')=1 then
  Raise_Application_Error(-20001, 'Transaction not allowed on Sunday');
end if;
end;
/

Pl/ Sql Trigger to validate student table when user is trying to delete records.
---------------------
CREATE OR REPLACE TRIGGER  TR_STU_DEL
BEFORE DELETE  ON  STUDENT
FOR EACH ROW
DECLARE
BEGIN
Raise_Application_Error(-20001, ' U CANNOT DELETE ROW');

END;
/
=============================================
 Oracle's syntax for creating a trigger based on two tables:
------------------------------------------------------------------------------
SQL> CREATE TABLE myTable1 (a INTEGER, b CHAR(10));

SQL> CREATE TABLE myTable2 (c CHAR(10), d INTEGER);

SQL>
CREATE OR REPLACE TRIGGER trig1
AFTER INSERT ON myTable1
REFERENCING NEW AS newRow
FOR EACH ROW
WHEN (newRow.a <= 10)
BEGIN
INSERT INTO myTable2 VALUES(:newRow.b, :newRow.a);
END trig1;
/

SQL> insert into myTable1 values(1,'a');

SQL> insert into myTable1 values(2,'b');

SQL> select * from myTable1;

SQL> select * from myTable2;

Whenever we insert values in the myTable1 the Trigger will insert the same values in myTable2 also.


 To enable/disable trigger:
 SQL > Alter trigger <Triggername> enable/disable;

To drop trigger:
SQL > Drop trigger <Trigger name>


